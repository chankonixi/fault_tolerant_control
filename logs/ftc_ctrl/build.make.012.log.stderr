[01m[K/home/cheng/fault_tolerant_control/src/ftc_ctrl/src/ftc_ctrl.cpp:[m[K In member function â€˜[01m[Kvoid ftc::NDICtrl::RungeKuttaProgess(const Vector3d&, Eigen::Vector3d&, const Vector3d&, Eigen::Vector3d&)[m[Kâ€™:
[01m[K/home/cheng/fault_tolerant_control/src/ftc_ctrl/src/ftc_ctrl.cpp:622:11:[m[K [01;31m[Kerror: [m[Kno match for â€˜[01m[Koperator=[m[Kâ€™ (operand types are â€˜[01m[Kconst Vector3d {aka const Eigen::Matrix<double, 3, 1>}[m[Kâ€™ and â€˜[01m[KEigen::Vector3d {aka Eigen::Matrix<double, 3, 1>}[m[Kâ€™)
     Rx_in=[01;31m[KRx_out[m[K;                                         Ry_in=Ry_out;
           [01;31m[K^~~~~~[m[K
In file included from [01m[K/usr/include/eigen3/Eigen/Core:438:0[m[K,
                 from [01m[K/usr/include/eigen3/Eigen/Dense:1[m[K,
                 from [01m[K/home/cheng/fault_tolerant_control/src/ftc_ctrl/include/ftc_ctrl/ftc_ctrl.h:31[m[K,
                 from [01m[K/home/cheng/fault_tolerant_control/src/ftc_ctrl/src/ftc_ctrl.cpp:22[m[K:
[01m[K/usr/include/eigen3/Eigen/src/Core/Matrix.h:206:33:[m[K [01;36m[Knote: [m[Kcandidate: Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>&) [with _Scalar = double; int _Rows = 3; int _Cols = 1; int _Options = 0; int _MaxRows = 3; int _MaxCols = 1] <near match>
     EIGEN_STRONG_INLINE Matrix& [01;36m[Koperator[m[K=(const Matrix& other)
                                 [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/Matrix.h:206:33:[m[K [01;36m[Knote: [m[K  passing â€˜[01m[Kconst Vector3d* {aka const Eigen::Matrix<double, 3, 1>*}[m[Kâ€™ as â€˜[01m[Kthis[m[Kâ€™ argument discards qualifiers
[01m[K/usr/include/eigen3/Eigen/src/Core/Matrix.h:223:33:[m[K [01;36m[Knote: [m[Kcandidate: Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 3, 1>; _Scalar = double; int _Rows = 3; int _Cols = 1; int _Options = 0; int _MaxRows = 3; int _MaxCols = 1] <near match>
     EIGEN_STRONG_INLINE Matrix& [01;36m[Koperator[m[K=(const DenseBase<OtherDerived>& other)
                                 [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/Matrix.h:223:33:[m[K [01;36m[Knote: [m[K  passing â€˜[01m[Kconst Vector3d* {aka const Eigen::Matrix<double, 3, 1>*}[m[Kâ€™ as â€˜[01m[Kthis[m[Kâ€™ argument discards qualifiers
[01m[K/usr/include/eigen3/Eigen/src/Core/Matrix.h:236:33:[m[K [01;36m[Knote: [m[Kcandidate: Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 3, 1>; _Scalar = double; int _Rows = 3; int _Cols = 1; int _Options = 0; int _MaxRows = 3; int _MaxCols = 1] <near match>
     EIGEN_STRONG_INLINE Matrix& [01;36m[Koperator[m[K=(const EigenBase<OtherDerived> &other)
                                 [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/Matrix.h:236:33:[m[K [01;36m[Knote: [m[K  passing â€˜[01m[Kconst Vector3d* {aka const Eigen::Matrix<double, 3, 1>*}[m[Kâ€™ as â€˜[01m[Kthis[m[Kâ€™ argument discards qualifiers
[01m[K/usr/include/eigen3/Eigen/src/Core/Matrix.h:243:33:[m[K [01;36m[Knote: [m[Kcandidate: template<class OtherDerived> Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::ReturnByValue<OtherDerived>&) [with OtherDerived = OtherDerived; _Scalar = double; int _Rows = 3; int _Cols = 1; int _Options = 0; int _MaxRows = 3; int _MaxCols = 1]
     EIGEN_STRONG_INLINE Matrix& [01;36m[Koperator[m[K=(const ReturnByValue<OtherDerived>& func)
                                 [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/Matrix.h:243:33:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/cheng/fault_tolerant_control/src/ftc_ctrl/src/ftc_ctrl.cpp:622:11:[m[K [01;36m[Knote: [m[K  â€˜[01m[KEigen::Vector3d {aka Eigen::Matrix<double, 3, 1>}[m[Kâ€™ is not derived from â€˜[01m[Kconst Eigen::ReturnByValue<Derived>[m[Kâ€™
     Rx_in=[01;36m[KRx_out[m[K;                                         Ry_in=Ry_out;
           [01;36m[K^~~~~~[m[K
In file included from [01m[K/usr/include/eigen3/Eigen/Core:438:0[m[K,
                 from [01m[K/usr/include/eigen3/Eigen/Dense:1[m[K,
                 from [01m[K/home/cheng/fault_tolerant_control/src/ftc_ctrl/include/ftc_ctrl/ftc_ctrl.h:31[m[K,
                 from [01m[K/home/cheng/fault_tolerant_control/src/ftc_ctrl/src/ftc_ctrl.cpp:22[m[K:
[01m[K/usr/include/eigen3/Eigen/src/Core/Matrix.h:281:13:[m[K [01;36m[Knote: [m[Kcandidate: Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>&&) [with _Scalar = double; int _Rows = 3; int _Cols = 1; int _Options = 0; int _MaxRows = 3; int _MaxCols = 1] <near match>
     Matrix& [01;36m[Koperator[m[K=(Matrix&& other) EIGEN_NOEXCEPT_IF(std::is_nothrow_move_assignable<Scalar>::value)
             [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/Matrix.h:281:13:[m[K [01;36m[Knote: [m[K  conversion of argument 1 would be ill-formed:
[01m[K/home/cheng/fault_tolerant_control/src/ftc_ctrl/src/ftc_ctrl.cpp:622:11:[m[K [01;31m[Kerror: [m[Kcannot bind rvalue reference of type â€˜[01m[KEigen::Matrix<double, 3, 1>&&[m[Kâ€™ to lvalue of type â€˜[01m[KEigen::Vector3d {aka Eigen::Matrix<double, 3, 1>}[m[Kâ€™
     Rx_in=[01;31m[KRx_out[m[K;                                         Ry_in=Ry_out;
           [01;31m[K^~~~~~[m[K
In file included from [01m[K/usr/include/eigen3/Eigen/Core:438:0[m[K,
                 from [01m[K/usr/include/eigen3/Eigen/Dense:1[m[K,
                 from [01m[K/home/cheng/fault_tolerant_control/src/ftc_ctrl/include/ftc_ctrl/ftc_ctrl.h:31[m[K,
                 from [01m[K/home/cheng/fault_tolerant_control/src/ftc_ctrl/src/ftc_ctrl.cpp:22[m[K:
[01m[K/usr/include/eigen3/Eigen/src/Core/Matrix.h:392:13:[m[K [01;36m[Knote: [m[Kcandidate: template<class OtherDerived> Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::RotationBase<OtherDerived, ColsAtCompileTime>&) [with OtherDerived = OtherDerived; _Scalar = double; int _Rows = 3; int _Cols = 1; int _Options = 0; int _MaxRows = 3; int _MaxCols = 1]
     Matrix& [01;36m[Koperator[m[K=(const RotationBase<OtherDerived,ColsAtCompileTime>& r);
             [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/Matrix.h:392:13:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/cheng/fault_tolerant_control/src/ftc_ctrl/src/ftc_ctrl.cpp:622:11:[m[K [01;36m[Knote: [m[K  â€˜[01m[KEigen::Vector3d {aka Eigen::Matrix<double, 3, 1>}[m[Kâ€™ is not derived from â€˜[01m[Kconst Eigen::RotationBase<OtherDerived, 1>[m[Kâ€™
     Rx_in=[01;36m[KRx_out[m[K;                                         Ry_in=Ry_out;
           [01;36m[K^~~~~~[m[K
[01m[K/home/cheng/fault_tolerant_control/src/ftc_ctrl/src/ftc_ctrl.cpp:622:65:[m[K [01;31m[Kerror: [m[Kno match for â€˜[01m[Koperator=[m[Kâ€™ (operand types are â€˜[01m[Kconst Vector3d {aka const Eigen::Matrix<double, 3, 1>}[m[Kâ€™ and â€˜[01m[KEigen::Vector3d {aka Eigen::Matrix<double, 3, 1>}[m[Kâ€™)
     Rx_in=Rx_out;                                         Ry_in=[01;31m[KRy_out[m[K;
                                                                 [01;31m[K^~~~~~[m[K
In file included from [01m[K/usr/include/eigen3/Eigen/Core:438:0[m[K,
                 from [01m[K/usr/include/eigen3/Eigen/Dense:1[m[K,
                 from [01m[K/home/cheng/fault_tolerant_control/src/ftc_ctrl/include/ftc_ctrl/ftc_ctrl.h:31[m[K,
                 from [01m[K/home/cheng/fault_tolerant_control/src/ftc_ctrl/src/ftc_ctrl.cpp:22[m[K:
[01m[K/usr/include/eigen3/Eigen/src/Core/Matrix.h:206:33:[m[K [01;36m[Knote: [m[Kcandidate: Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>&) [with _Scalar = double; int _Rows = 3; int _Cols = 1; int _Options = 0; int _MaxRows = 3; int _MaxCols = 1] <near match>
     EIGEN_STRONG_INLINE Matrix& [01;36m[Koperator[m[K=(const Matrix& other)
                                 [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/Matrix.h:206:33:[m[K [01;36m[Knote: [m[K  passing â€˜[01m[Kconst Vector3d* {aka const Eigen::Matrix<double, 3, 1>*}[m[Kâ€™ as â€˜[01m[Kthis[m[Kâ€™ argument discards qualifiers
[01m[K/usr/include/eigen3/Eigen/src/Core/Matrix.h:223:33:[m[K [01;36m[Knote: [m[Kcandidate: Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 3, 1>; _Scalar = double; int _Rows = 3; int _Cols = 1; int _Options = 0; int _MaxRows = 3; int _MaxCols = 1] <near match>
     EIGEN_STRONG_INLINE Matrix& [01;36m[Koperator[m[K=(const DenseBase<OtherDerived>& other)
                                 [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/Matrix.h:223:33:[m[K [01;36m[Knote: [m[K  passing â€˜[01m[Kconst Vector3d* {aka const Eigen::Matrix<double, 3, 1>*}[m[Kâ€™ as â€˜[01m[Kthis[m[Kâ€™ argument discards qualifiers
[01m[K/usr/include/eigen3/Eigen/src/Core/Matrix.h:236:33:[m[K [01;36m[Knote: [m[Kcandidate: Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 3, 1>; _Scalar = double; int _Rows = 3; int _Cols = 1; int _Options = 0; int _MaxRows = 3; int _MaxCols = 1] <near match>
     EIGEN_STRONG_INLINE Matrix& [01;36m[Koperator[m[K=(const EigenBase<OtherDerived> &other)
                                 [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/Matrix.h:236:33:[m[K [01;36m[Knote: [m[K  passing â€˜[01m[Kconst Vector3d* {aka const Eigen::Matrix<double, 3, 1>*}[m[Kâ€™ as â€˜[01m[Kthis[m[Kâ€™ argument discards qualifiers
[01m[K/usr/include/eigen3/Eigen/src/Core/Matrix.h:243:33:[m[K [01;36m[Knote: [m[Kcandidate: template<class OtherDerived> Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::ReturnByValue<OtherDerived>&) [with OtherDerived = OtherDerived; _Scalar = double; int _Rows = 3; int _Cols = 1; int _Options = 0; int _MaxRows = 3; int _MaxCols = 1]
     EIGEN_STRONG_INLINE Matrix& [01;36m[Koperator[m[K=(const ReturnByValue<OtherDerived>& func)
                                 [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/Matrix.h:243:33:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/cheng/fault_tolerant_control/src/ftc_ctrl/src/ftc_ctrl.cpp:622:65:[m[K [01;36m[Knote: [m[K  â€˜[01m[KEigen::Vector3d {aka Eigen::Matrix<double, 3, 1>}[m[Kâ€™ is not derived from â€˜[01m[Kconst Eigen::ReturnByValue<Derived>[m[Kâ€™
     Rx_in=Rx_out;                                         Ry_in=[01;36m[KRy_out[m[K;
                                                                 [01;36m[K^~~~~~[m[K
In file included from [01m[K/usr/include/eigen3/Eigen/Core:438:0[m[K,
                 from [01m[K/usr/include/eigen3/Eigen/Dense:1[m[K,
                 from [01m[K/home/cheng/fault_tolerant_control/src/ftc_ctrl/include/ftc_ctrl/ftc_ctrl.h:31[m[K,
                 from [01m[K/home/cheng/fault_tolerant_control/src/ftc_ctrl/src/ftc_ctrl.cpp:22[m[K:
[01m[K/usr/include/eigen3/Eigen/src/Core/Matrix.h:281:13:[m[K [01;36m[Knote: [m[Kcandidate: Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>&&) [with _Scalar = double; int _Rows = 3; int _Cols = 1; int _Options = 0; int _MaxRows = 3; int _MaxCols = 1] <near match>
     Matrix& [01;36m[Koperator[m[K=(Matrix&& other) EIGEN_NOEXCEPT_IF(std::is_nothrow_move_assignable<Scalar>::value)
             [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/Matrix.h:281:13:[m[K [01;36m[Knote: [m[K  conversion of argument 1 would be ill-formed:
[01m[K/home/cheng/fault_tolerant_control/src/ftc_ctrl/src/ftc_ctrl.cpp:622:65:[m[K [01;31m[Kerror: [m[Kcannot bind rvalue reference of type â€˜[01m[KEigen::Matrix<double, 3, 1>&&[m[Kâ€™ to lvalue of type â€˜[01m[KEigen::Vector3d {aka Eigen::Matrix<double, 3, 1>}[m[Kâ€™
     Rx_in=Rx_out;                                         Ry_in=[01;31m[KRy_out[m[K;
                                                                 [01;31m[K^~~~~~[m[K
In file included from [01m[K/usr/include/eigen3/Eigen/Core:438:0[m[K,
                 from [01m[K/usr/include/eigen3/Eigen/Dense:1[m[K,
                 from [01m[K/home/cheng/fault_tolerant_control/src/ftc_ctrl/include/ftc_ctrl/ftc_ctrl.h:31[m[K,
                 from [01m[K/home/cheng/fault_tolerant_control/src/ftc_ctrl/src/ftc_ctrl.cpp:22[m[K:
[01m[K/usr/include/eigen3/Eigen/src/Core/Matrix.h:392:13:[m[K [01;36m[Knote: [m[Kcandidate: template<class OtherDerived> Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::RotationBase<OtherDerived, ColsAtCompileTime>&) [with OtherDerived = OtherDerived; _Scalar = double; int _Rows = 3; int _Cols = 1; int _Options = 0; int _MaxRows = 3; int _MaxCols = 1]
     Matrix& [01;36m[Koperator[m[K=(const RotationBase<OtherDerived,ColsAtCompileTime>& r);
             [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/Matrix.h:392:13:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/cheng/fault_tolerant_control/src/ftc_ctrl/src/ftc_ctrl.cpp:622:65:[m[K [01;36m[Knote: [m[K  â€˜[01m[KEigen::Vector3d {aka Eigen::Matrix<double, 3, 1>}[m[Kâ€™ is not derived from â€˜[01m[Kconst Eigen::RotationBase<OtherDerived, 1>[m[Kâ€™
     Rx_in=Rx_out;                                         Ry_in=[01;36m[KRy_out[m[K;
                                                                 [01;36m[K^~~~~~[m[K
In file included from [01m[K/usr/include/eigen3/Eigen/Core:347:0[m[K,
                 from [01m[K/usr/include/eigen3/Eigen/Dense:1[m[K,
                 from [01m[K/home/cheng/fault_tolerant_control/src/ftc_ctrl/include/ftc_ctrl/ftc_ctrl.h:31[m[K,
                 from [01m[K/home/cheng/fault_tolerant_control/src/ftc_ctrl/src/ftc_ctrl.cpp:22[m[K:
/usr/include/eigen3/Eigen/src/Core/GeneralProduct.h: In instantiation of â€˜[01m[Kconst Eigen::Product<Derived, OtherDerived> Eigen::MatrixBase<Derived>::operator*(const Eigen::MatrixBase<OtherDerived>&) const [with OtherDerived = Eigen::Matrix<double, 3, 1>; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™:
[01m[K/home/cheng/fault_tolerant_control/src/ftc_ctrl/src/ftc_ctrl.cpp:618:28:[m[K   required from here
[01m[K/usr/include/eigen3/Eigen/src/Core/util/StaticAssert.h:32:40:[m[K [01;31m[Kerror: [m[Kstatic assertion failed: INVALID_VECTOR_VECTOR_PRODUCT__IF_YOU_WANTED_A_DOT_OR_COEFF_WISE_PRODUCT_YOU_MUST_USE_THE_EXPLICIT_FUNCTIONS
     #define EIGEN_STATIC_ASSERT(X,MSG) [01;31m[Ks[m[Ktatic_assert(X,#MSG);
                                        [01;31m[K^[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/util/StaticAssert.h:32:40:[m[K [01;36m[Knote: [m[Kin definition of macro â€˜[01m[KEIGEN_STATIC_ASSERT[m[Kâ€™
     #define EIGEN_STATIC_ASSERT(X,MSG) [01;36m[Kstatic_assert[m[K(X,#MSG);
                                        [01;36m[K^~~~~~~~~~~~~[m[K
/usr/include/eigen3/Eigen/src/Core/GeneralProduct.h: In instantiation of â€˜[01m[Kconst Eigen::Product<Derived, OtherDerived> Eigen::MatrixBase<Derived>::operator*(const Eigen::MatrixBase<OtherDerived>&) const [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double, double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double, double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double, double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 3, 1> >, const Eigen::Matrix<double, 3, 1> > >, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 3, 1> >, const Eigen::Matrix<double, 3, 1> > >, const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™:
[01m[K/home/cheng/fault_tolerant_control/src/ftc_ctrl/src/ftc_ctrl.cpp:621:46:[m[K   required from here
[01m[K/usr/include/eigen3/Eigen/src/Core/util/StaticAssert.h:32:40:[m[K [01;31m[Kerror: [m[Kstatic assertion failed: INVALID_VECTOR_VECTOR_PRODUCT__IF_YOU_WANTED_A_DOT_OR_COEFF_WISE_PRODUCT_YOU_MUST_USE_THE_EXPLICIT_FUNCTIONS
     #define EIGEN_STATIC_ASSERT(X,MSG) [01;31m[Ks[m[Ktatic_assert(X,#MSG);
                                        [01;31m[K^[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/util/StaticAssert.h:32:40:[m[K [01;36m[Knote: [m[Kin definition of macro â€˜[01m[KEIGEN_STATIC_ASSERT[m[Kâ€™
     #define EIGEN_STATIC_ASSERT(X,MSG) [01;36m[Kstatic_assert[m[K(X,#MSG);
                                        [01;36m[K^~~~~~~~~~~~~[m[K
/usr/include/eigen3/Eigen/src/Core/GeneralProduct.h: In instantiation of â€˜[01m[Kconst Eigen::Product<Derived, OtherDerived, 1> Eigen::MatrixBase<Derived>::lazyProduct(const Eigen::MatrixBase<OtherDerived>&) const [with OtherDerived = Eigen::Matrix<double, 3, 1>; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™:
[01m[K/usr/include/eigen3/Eigen/src/Core/ProductEvaluators.h:404:29:[m[K   required from â€˜[01m[Kstatic void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 3>::addTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<double, 3, 1>; Lhs = Eigen::Matrix<double, 3, 1>; Rhs = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/include/eigen3/Eigen/src/Core/ProductEvaluators.h:163:42:[m[K   required from â€˜[01m[Kstatic void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::add_assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::add_assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<double, 3, 1>; Lhs = Eigen::Matrix<double, 3, 1>; Rhs = Eigen::Matrix<double, 3, 1>; int Options = 0; Scalar = double; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::add_assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Matrix<double, 3, 1>, Eigen::Matrix<double, 3, 1>, 0>][m[Kâ€™
[01m[K/usr/include/eigen3/Eigen/src/Core/AssignEvaluator.h:836:49:[m[K   required from â€˜[01m[Kvoid Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, 3, 1>; Src = Eigen::Product<Eigen::Matrix<double, 3, 1>, Eigen::Matrix<double, 3, 1>, 0>; Func = Eigen::internal::add_assign_op<double, double>][m[Kâ€™
[01m[K/usr/include/eigen3/Eigen/src/Core/ProductEvaluators.h:224:29:[m[K   required from â€˜[01m[Kstatic void Eigen::internal::assignment_from_xpr_op_product<DstXprType, OtherXpr, ProductType, Func1, Func2>::run(DstXprType&, const SrcXprType&, const InitialFunc&) [with SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double, double>, const Eigen::Matrix<double, 3, 1>, const Eigen::Product<Eigen::Matrix<double, 3, 1>, Eigen::Matrix<double, 3, 1>, 0> >; InitialFunc = Eigen::internal::assign_op<double, double>; DstXprType = Eigen::Matrix<double, 3, 1>; OtherXpr = Eigen::Matrix<double, 3, 1>; ProductType = Eigen::Product<Eigen::Matrix<double, 3, 1>, Eigen::Matrix<double, 3, 1>, 0>; Func1 = Eigen::internal::assign_op<double, double>; Func2 = Eigen::internal::add_assign_op<double, double>][m[Kâ€™
[01m[K/usr/include/eigen3/Eigen/src/Core/AssignEvaluator.h:836:49:[m[K   required from â€˜[01m[Kvoid Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, 3, 1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double, double>, const Eigen::Matrix<double, 3, 1>, const Eigen::Product<Eigen::Matrix<double, 3, 1>, Eigen::Matrix<double, 3, 1>, 0> >; Func = Eigen::internal::assign_op<double, double>][m[Kâ€™
[01m[K/usr/include/eigen3/Eigen/src/Core/PlainObjectBase.h:728:41:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double, double>, const Eigen::Matrix<double, 3, 1>, const Eigen::Product<Eigen::Matrix<double, 3, 1>, Eigen::Matrix<double, 3, 1>, 0> >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/include/eigen3/Eigen/src/Core/PlainObjectBase.h:537:19:[m[K   required from â€˜[01m[KEigen::PlainObjectBase<Derived>::PlainObjectBase(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double, double>, const Eigen::Matrix<double, 3, 1>, const Eigen::Product<Eigen::Matrix<double, 3, 1>, Eigen::Matrix<double, 3, 1>, 0> >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/include/eigen3/Eigen/src/Core/Matrix.h:379:29:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double, double>, const Eigen::Matrix<double, 3, 1>, const Eigen::Product<Eigen::Matrix<double, 3, 1>, Eigen::Matrix<double, 3, 1>, 0> >; _Scalar = double; int _Rows = 3; int _Cols = 1; int _Options = 0; int _MaxRows = 3; int _MaxCols = 1][m[Kâ€™
[01m[K/home/cheng/fault_tolerant_control/src/ftc_ctrl/src/ftc_ctrl.cpp:620:46:[m[K   required from here
[01m[K/usr/include/eigen3/Eigen/src/Core/util/StaticAssert.h:32:40:[m[K [01;31m[Kerror: [m[Kstatic assertion failed: INVALID_VECTOR_VECTOR_PRODUCT__IF_YOU_WANTED_A_DOT_OR_COEFF_WISE_PRODUCT_YOU_MUST_USE_THE_EXPLICIT_FUNCTIONS
     #define EIGEN_STATIC_ASSERT(X,MSG) [01;31m[Ks[m[Ktatic_assert(X,#MSG);
                                        [01;31m[K^[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/util/StaticAssert.h:32:40:[m[K [01;36m[Knote: [m[Kin definition of macro â€˜[01m[KEIGEN_STATIC_ASSERT[m[Kâ€™
     #define EIGEN_STATIC_ASSERT(X,MSG) [01;36m[Kstatic_assert[m[K(X,#MSG);
                                        [01;36m[K^~~~~~~~~~~~~[m[K
/usr/include/eigen3/Eigen/src/Core/CwiseBinaryOp.h: In instantiation of â€˜[01m[KEigen::CwiseBinaryOp<BinaryOp, Lhs, Rhs>::CwiseBinaryOp(const Lhs&, const Rhs&, const BinaryOp&) [with BinaryOp = Eigen::internal::scalar_product_op<double, double>; LhsType = const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<double, 3, 1>, 1, 1, false> >; RhsType = const Eigen::Block<const Eigen::Matrix<double, 3, 1>, 3, 1, true>; Eigen::CwiseBinaryOp<BinaryOp, Lhs, Rhs>::Lhs = Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<double, 3, 1>, 1, 1, false> >; Eigen::CwiseBinaryOp<BinaryOp, Lhs, Rhs>::Rhs = Eigen::Block<const Eigen::Matrix<double, 3, 1>, 3, 1, true>][m[Kâ€™:
[01m[K/usr/include/eigen3/Eigen/src/Core/../plugins/MatrixCwiseBinaryOps.h:25:10:[m[K   required from â€˜[01m[Kconst Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<typename Eigen::internal::traits<T>::Scalar, typename Eigen::internal::traits<OtherDerived>::Scalar>, const Derived, const OtherDerived> Eigen::MatrixBase<Derived>::cwiseProduct(const Eigen::MatrixBase<OtherDerived>&) const [with OtherDerived = Eigen::Block<const Eigen::Matrix<double, 3, 1>, 3, 1, true>; Derived = Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<double, 3, 1>, 1, 1, false> >; typename Eigen::internal::traits<OtherDerived>::Scalar = double; typename Eigen::internal::traits<T>::Scalar = double][m[Kâ€™
[01m[K/usr/include/eigen3/Eigen/src/Core/ProductEvaluators.h:552:72:[m[K   required from â€˜[01m[Kconst CoeffReturnType Eigen::internal::product_evaluator<Eigen::Product<Lhs, Rhs, 1>, ProductTag, Eigen::DenseShape, Eigen::DenseShape>::coeff(Eigen::Index, Eigen::Index) const [with Lhs = Eigen::Matrix<double, 3, 1>; Rhs = Eigen::Matrix<double, 3, 1>; int ProductTag = 3; typename Eigen::internal::traits<typename Eigen::Product<Lhs, Rhs, 1>::Rhs>::Scalar = double; typename Eigen::internal::traits<typename Eigen::Product<Lhs, Rhs, 1>::Lhs>::Scalar = double; Eigen::internal::product_evaluator<Eigen::Product<Lhs, Rhs, 1>, ProductTag, Eigen::DenseShape, Eigen::DenseShape>::CoeffReturnType = double; Eigen::Index = long int][m[Kâ€™
[01m[K/usr/include/eigen3/Eigen/src/Core/CoreEvaluators.h:713:74:[m[K   required from â€˜[01m[KEigen::internal::binary_evaluator<Eigen::CwiseBinaryOp<BinaryOp, Lhs, Rhs>, Eigen::internal::IndexBased, Eigen::internal::IndexBased>::CoeffReturnType Eigen::internal::binary_evaluator<Eigen::CwiseBinaryOp<BinaryOp, Lhs, Rhs>, Eigen::internal::IndexBased, Eigen::internal::IndexBased>::coeff(Eigen::Index, Eigen::Index) const [with BinaryOp = Eigen::internal::scalar_sum_op<double, double>; Lhs = const Eigen::Matrix<double, 3, 1>; Rhs = const Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Matrix<double, 3, 1>, Eigen::Matrix<double, 3, 1>, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 3, 1> > >; typename Eigen::internal::traits<typename Eigen::CwiseBinaryOp<BinaryOp, Lhs, Rhs>::Rhs>::Scalar = double; typename Eigen::internal::traits<typename Eigen::CwiseBinaryOp<BinaryOp, Lhs, Rhs>::Lhs>::Scalar = double; Eigen::internal::binary_evaluator<Eigen::CwiseBinaryOp<BinaryOp, Lhs, Rhs>, Eigen::internal::IndexBased, Eigen::internal::IndexBased>::CoeffReturnType = double; Eigen::Index = long int][m[Kâ€™
[01m[K/usr/include/eigen3/Eigen/src/Core/AssignEvaluator.h:631:5:[m[K   required from â€˜[01m[Kvoid Eigen::internal::generic_dense_assignment_kernel<DstEvaluatorTypeT, SrcEvaluatorTypeT, Functor, Version>::assignCoeff(Eigen::Index, Eigen::Index) [with DstEvaluatorTypeT = Eigen::internal::evaluator<Eigen::Matrix<double, 3, 1> >; SrcEvaluatorTypeT = Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double, double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Matrix<double, 3, 1>, Eigen::Matrix<double, 3, 1>, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 3, 1> > > > >; Functor = Eigen::internal::assign_op<double, double>; int Version = 0; Eigen::Index = long int][m[Kâ€™
[01m[K/usr/include/eigen3/Eigen/src/Core/AssignEvaluator.h:645:16:[m[K   [ skipping 3 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/include/eigen3/Eigen/src/Core/AssignEvaluator.h:741:37:[m[K   required from â€˜[01m[Kvoid Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, 3, 1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double, double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Matrix<double, 3, 1>, Eigen::Matrix<double, 3, 1>, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 3, 1> > > >; Functor = Eigen::internal::assign_op<double, double>][m[Kâ€™
[01m[K/usr/include/eigen3/Eigen/src/Core/AssignEvaluator.h:879:31:[m[K   required from â€˜[01m[Kstatic void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, 3, 1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double, double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Matrix<double, 3, 1>, Eigen::Matrix<double, 3, 1>, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 3, 1> > > >; Functor = Eigen::internal::assign_op<double, double>; Weak = void][m[Kâ€™
[01m[K/usr/include/eigen3/Eigen/src/Core/AssignEvaluator.h:836:49:[m[K   required from â€˜[01m[Kvoid Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, 3, 1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double, double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Matrix<double, 3, 1>, Eigen::Matrix<double, 3, 1>, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 3, 1> > > >; Func = Eigen::internal::assign_op<double, double>][m[Kâ€™
[01m[K/usr/include/eigen3/Eigen/src/Core/PlainObjectBase.h:728:41:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double, double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Matrix<double, 3, 1>, Eigen::Matrix<double, 3, 1>, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 3, 1> > > >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/include/eigen3/Eigen/src/Core/PlainObjectBase.h:537:19:[m[K   required from â€˜[01m[KEigen::PlainObjectBase<Derived>::PlainObjectBase(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double, double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Matrix<double, 3, 1>, Eigen::Matrix<double, 3, 1>, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 3, 1> > > >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/include/eigen3/Eigen/src/Core/Matrix.h:379:29:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double, double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Matrix<double, 3, 1>, Eigen::Matrix<double, 3, 1>, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 3, 1> > > >; _Scalar = double; int _Rows = 3; int _Cols = 1; int _Options = 0; int _MaxRows = 3; int _MaxCols = 1][m[Kâ€™
[01m[K/home/cheng/fault_tolerant_control/src/ftc_ctrl/src/ftc_ctrl.cpp:618:50:[m[K   required from here
[01m[K/usr/include/eigen3/Eigen/src/Core/util/StaticAssert.h:32:40:[m[K [01;31m[Kerror: [m[Kstatic assertion failed: YOU_MIXED_MATRICES_OF_DIFFERENT_SIZES
     #define EIGEN_STATIC_ASSERT(X,MSG) [01;31m[Ks[m[Ktatic_assert(X,#MSG);
                                        [01;31m[K^[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/util/StaticAssert.h:32:40:[m[K [01;36m[Knote: [m[Kin definition of macro â€˜[01m[KEIGEN_STATIC_ASSERT[m[Kâ€™
     #define EIGEN_STATIC_ASSERT(X,MSG) [01;36m[Kstatic_assert[m[K(X,#MSG);
                                        [01;36m[K^~~~~~~~~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/CwiseBinaryOp.h:109:7:[m[K [01;36m[Knote: [m[Kin expansion of macro â€˜[01m[KEIGEN_STATIC_ASSERT_SAME_MATRIX_SIZE[m[Kâ€™
       [01;36m[KE[m[KIGEN_STATIC_ASSERT_SAME_MATRIX_SIZE(Lhs, Rhs)
       [01;36m[K^[m[K
make[2]: *** [CMakeFiles/ftc_ctrl.dir/src/ftc_ctrl.cpp.o] Error 1
make[1]: *** [CMakeFiles/ftc_ctrl.dir/all] Error 2
make: *** [all] Error 2
